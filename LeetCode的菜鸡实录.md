# LeetCode的菜鸡实录

## 1、两数之和

**重点：HashMap(c++ unordered_map)**

通过查找之前已经加入的数字，判断当前加入的数字是否能和之前已经加入的数字进行组合，得到结果。不必先全部加入再进行逐一查找的操作，减少次数，将两遍哈希表变为一遍即可完成。

**一遍哈希表**

事实证明，我们可以一次完成。在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。

**复杂度分析：**

- 时间复杂度：O(n)， 我们只遍历了包含有 n 个元素的列表一次。在表中进行的每次查找只花费 O(1) 的时间。
- 空间复杂度：O(n)， 所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储 n 个元素。

**延伸：迭代器**

## 2、两数相加

**重点：链表的使用**

常规思路，主要问题是链表的使用，如何操作链表，另外留意进位以及何时终止的判断。

**复杂度分析**

- 时间复杂度：O(max⁡(m,n))，假设 m 和 n 分别表示 l1 和 l2 的长度，上面的算法最多重复 max⁡(m,n) 次。
- 空间复杂度：O(max⁡(m,n))， 新列表的长度最多为 max⁡(m,n)+1。

**延伸：结构体**

定义结构体，初始化结构体，结构体赋值，结构体函数

## 3、无重复字符的最长子串

**重点：思路**

实际上就是从非重复的开始往后找，找到第一个在当前的串中重复的字符。因为要找最长，所以比较当前串的长度和现有的最长长度，取其大者。然后直接将位置挪到串中发生重复的字符后的那位，继续向后找即可。

**方法三：优化的滑动窗口**

上述的方法最多需要执行 2n 个步骤。事实上，它可以被进一步优化为仅需要 n 个步骤。我们可以定义字符到索引的映射，而不是使用集合来判断一个字符是否存在。 当我们找到重复的字符时，我们可以立即跳过该窗口。

也就是说，如果 s[j] 在 [i,j) 范围内有与 j′ 重复的字符，我们不需要逐渐增加 i 。 我们可以直接跳过 [i，j′] 范围内的所有元素，并将 i 变为 j′+1。

**复杂度分析**

- 时间复杂度：O(n)，索引 jjj 将会迭代 n 次。
- 空间复杂度（HashMap）：O(min(m,n))，与之前的方法相同。
- 空间复杂度（Table）：O(m)，m 是字符集的大小。

这里使用unordered_map、字符串还有unordered_set都可以。核心思想是相同的，unordered_set思路更为明显。

**延伸：unordered_set**

## 4、寻找两个有序数组的中位数

**重点：思路+边界分析**

第一道困难就被锤到自闭…

其实大概的思路是想到了，可做，但是还是脑筋太死，其实变通一下可能完整思路就有了。当然了，对着例程都错了半天，真的是把以前的东西都还光了。

题目和之前算法课上面的等长串求中位数有些类似，因为是有序的，所以肯定是在某点进行分割，只是不等长的情况下需要稍微进行一些修改。

[题解超长](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/)

用自己的语言来解释下：

中位数肯定是能够使两个数组总的个数长度左右平分的，所以相当于是在两个数组之间有分隔线把左右的内容隔开。这里为了保证之后进行判断的时候可以不用讨论多种情况，所以上来第一步就是把两个数组的个数多少确定了下来，个数少的为nums1，多的为nums2。这里特别注意，**交换完之后把数组的长度也要换**，智障如我对着样例改的时候死活不对，就是忘了交换两个数组的长度。由于在两个数组中的分割线实际上是有关联的。为了保证大于和小于的个数相同，nums1中的分割线发生了移动，相应的nums2中的分割线也要发生变动。这里使选择较小的那个作为自变量，多的数组作为因变量。（关于在较小的数组端点也是有可能的特殊情况）在分割线的左右之间是具有关联的，这里的关联是指不同的数组之间有着大小关系（同数组之间有序肯定是有关系的），通过这样的限制条件来进行分割线的移动。

这道题目等过一段时间可以重做一遍，到时候应该会重新理解一下，然后再解释一遍，现在只是理解了大概的思想，但是在具体的问题中还是存在很多问题，比如对于边界问题限制的理解。

**延伸：中位数**

## 5、最长回文子串

**重点：回文**

其实在想到镜像做法之后，一度认为是否还能够继续节省时间复杂度，最后忍不住先瞄了一眼题解，发现复杂度没问题之后就写了。其实最后过的代码虽然复杂度相同，但是次数仍旧可以从两次的遍历降低为一次，就同第一题hashmap的优化一样。

**方法四：中心扩展算法**

事实上，只需使用恒定的空间，我们就可以在 O(n2) 的时间内解决这个问题。

我们观察到回文中心的两侧互为镜像。因此，回文可以从它的中心展开，并且只有 2n−1 个这样的中心。

你可能会问，为什么会是 2n−1 个，而不是 n 个中心？原因在于所含字母数为偶数的回文的中心可以处于两字母之间（例如 “abba” 的中心在两个 ‘b’ 之间）。

**复杂度分析**

- 时间复杂度：O(n2)， 由于围绕中心来扩展回文会耗去 O(n) 的时间，所以总的复杂度为 O(n2)。
- 空间复杂度：O(1)。

主要讲一下方法中将两次遍历减少为一次的思路吧，其实就是在一次的过程中对2位对称和3位对称均进行判断，不过需要特别注意如何控制左右边界的变化，具体可参考时间轴第二根的样例代码。

关于两次遍历降低为一次的实践留到之后复习的时候再进行尝试。

**延伸：动态规划、Manacher算法**

Manacher是O(n)的…这里贴两个讲解，待有空的时候可以理解一下。

[讲解1](https://segmentfault.com/a/1190000008484167?utm_source=tag-newest) [讲解2](https://www.jianshu.com/p/116aa58b7d81)

动态规划是肯定需要掌握的。在思考的时候其实没太往这方面去想，不过这个思想肯定还是要有的。[题解](https://leetcode-cn.com/problems/longest-palindromic-substring/solution/)中的方法三

看题解的时候，动态方程基本能理解，不过由于不是自己列的，所以还是需要等以后做到用动态规划的题目时再判断是否掌握。

## 6、Z字型变换

这题…做出来了，但是问题是这复杂度做炸了，其实看了题解之后发现思路没问题啊，就是手法用的不对，真是要死…

**讲道理，我写的代码真是又臭又长…除了能苟过样例还有啥用**

**方法二：按行访问**

**思路**

按照与逐行读取 Z 字形图案相同的顺序访问字符串。

**算法**

首先访问 `行 0` 中的所有字符，接着访问 `行 1`，然后 `行 2`，依此类推…

对于所有整数 k，

- 行 0 中的字符位于索引 k  (2⋅numRows−2)处;
- 行 numRows−1 中的字符位于索引 k  (2⋅numRows−2)+numRows−1 处;
- 内部的 行 i 中的字符位于索引 k  (2⋅numRows−2)+i 以及 (k+1)(2⋅numRows−2)−i 处;

**复杂度分析**

- 时间复杂度：O(n)，其中 n==len(s)。每个索引被访问一次。
- 空间复杂度：O(n)。对于 cpp 实现，如果返回字符串不被视为额外空间，则复杂度为 O(1)。

**延伸：边界值分析**

其实就是字符串长度为1的情况要单独讨论下

## 7、整数反转

**难度：简单** 是的，没错，就是简单，心态炸了。

思路无难度，代码无难度，然后失去理智疯狂交疯狂炸…

反正就是取模然后*10，唯一注意的就是边界值分析。

INT_MAX和INT_MIN，就是在下一次运算前先用这两个判断下会不会炸，会超过就直接返回0。另外因为**只能存储得下 32 位的有符号整数**，所以想用更大的类型偷鸡是不存在的…

[题解](https://leetcode-cn.com/problems/reverse-integer/solution/)

**延伸：INT_MAX和INT_MIN**

用这个可比pow什么方便多了

## 8、字符串转换整数

题解都没…

就是逐个识别字符，要一个符号标志和一个首位判断。不是首位且不在0-9之间返回，是首位为空直接找下一位，是首位非空，判断是否是符号，如果为-，，符号标志置1，消除首位标识，如果为+，仅消除首位标识即可，如果直接是数字就直接开始记录并消除首位标识。如果不是首位且读到字母，运算方式很简单，这里和之前的题目一样，要考虑超出范围直接返回上或下临界点。小于0用-，大于等于0用加。特别注意”-00001”这类情况，读到符号后的第一个非0数字才开始运算，并消除符号位，不然用0运算，符号位就会消失，正负发生错误。

总的来说细心+注意细节就行了，碰到的一些临界点的情况错过一次之后希望以后就能记住，然后日后写代码的时候多注意。

**延伸：NULL**

## 9、回文数

其实还可以用比过数据的代码更加节约的方法，也就是并不需要将整个数完全翻转完再判断，只需要翻转一般的数字比较即可。

其他需要注意的就是不要超过INT_MAX爆炸即可。

**方法：反转一半数字**

**思路**

映入脑海的第一个想法是将数字转换为字符串，并检查字符串是否为回文。但是，这需要额外的非常量空间来创建问题描述中所不允许的字符串。

第二个想法是将数字本身反转，然后将反转后的数字与原始数字进行比较，如果它们是相同的，那么这个数字就是回文。 但是，如果反转后的数字大于 int.MAX，我们将遇到整数溢出问题。

按照第二个想法，为了避免数字反转可能导致的溢出问题，为什么不考虑只反转 int\text{int}int 数字的一半？毕竟，如果该数字是回文，其后半部分反转后应该与原始数字的前半部分相同。

例如，输入 `1221`，我们可以将数字“12**21**”的后半部分从“**21**”反转为“**12**”，并将其与前半部分“12”进行比较，因为二者相同，我们得知数字 `1221` 是回文。

让我们看看如何将这个想法转化为一个算法。

**算法**

首先，我们应该处理一些临界情况。所有负数都不可能是回文，例如：-123 不是回文，因为 `-` 不等于 `3`。所以我们可以对所有负数返回 false。

现在，让我们来考虑如何反转后半部分的数字。 对于数字 `1221`，如果执行 `1221 % 10`，我们将得到最后一位数字 `1`，要得到倒数第二位数字，我们可以先通过除以 10 把最后一位数字从 `1221` 中移除，`1221 / 10 = 122`，再求出上一步结果除以10的余数，`122 % 10 = 2`，就可以得到倒数第二位数字。如果我们把最后一位数字乘以10，再加上倒数第二位数字，`1 * 10 + 2 = 12`，就得到了我们想要的反转后的数字。 如果继续这个过程，我们将得到更多位数的反转数字。

现在的问题是，我们如何知道反转数字的位数已经达到原始数字位数的一半？

我们将原始数字除以 10，然后给反转后的数字乘上 10，所以，当原始数字小于反转后的数字时，就意味着我们已经处理了一半位数的数字。

```
public class Solution {
    public bool IsPalindrome(int x) {
        // 特殊情况：
        // 如上所述，当 x < 0 时，x 不是回文数。
        // 同样地，如果数字的最后一位是 0，为了使该数字为回文，
        // 则其第一位数字也应该是 0
        // 只有 0 满足这一属性
        if(x < 0 || (x % 10 == 0 && x != 0)) {
            return false;
        }

        int revertedNumber = 0;
        while(x > revertedNumber) {
            revertedNumber = revertedNumber * 10 + x % 10;
            x /= 10;
        }

        // 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。
        // 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，
        // 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。
        return x == revertedNumber || x == revertedNumber/10;
    }
}
```

**复杂度分析**

- 时间复杂度：O(log⁡10(n))， 对于每次迭代，我们会将输入除以10，因此时间复杂度为 O(log⁡10(n))。
- 空间复杂度：O(1)。

直接返回false的if条件中能扩得越大越好，小于0和末位为0但原数不为0都可以直接清洗掉。

返回时候的或是用来规避奇数个位数和偶数个位数的情况。

**延伸：边界 INT_MAX判断**

## 10、正则表达式匹配(待解)

没写出来，最后肯定是涉及递归了，但是按照我的写法逻辑上应该有问题。

```
bool isMatch(string s, string p) {
    int temp1 = 0,temp2 = 0;
    while(temp2 < p.length()){
        if(p[temp2] >= 'a' && p[temp2] <= 'z'){
            if(temp2 + 1 < p.length() && p[temp2 + 1] == '*'){
                while(p[temp1++] == p[temp2])
                temp2 += 2;
            } else if(temp2 + 1 == p.length()){
                if(p[temp1] == p[temp2] && temp1 + 1 == s.length())
                    return true;
                else
                    return false;
            }
        } else if(p[temp2] == '.'){
            if(temp2 + 1 < p.length() && p[temp2 + 1] == '*'){
                if(temp2 + 2 == p.length())
                    return true;
                else{
                    while(!(p[temp2] >= 'a' && p[temp2] <= 'z')){
                        temp2++;
                    }
                    //  此处应该是一个进入的递归，但是如何判断是在第几个字母分割...
                }
            } else if(temp2 + 1 == p.length()){
                if(temp1 + 1 == s.length())
                    return true;
                else
                    return false;
            }
        }
    }
}
```

网页上也没有题解，下面是过得了之后别人的范例

```
class Solution {
public:
    vector<vector<int>> f;
    int m,n;
    bool isMatch(string s, string p) {
        n=s.size();
        m=p.size();
        f=vector<vector<int>>(n+1,vector<int>(m+1,-1));
        return dp(0,0,s,p);
    }
    
    int dp(int x,int y,string &s,string &p)
    {
        if(f[x][y]!=-1) 
            return f[x][y];
        if(y==m)
            return f[x][y]=x==n;
        bool first_match=x<n&&(s[x]==p[y]||p[y]=='.');
        bool ans;
        if(y+1<m&&p[y+1]=='*')
        {
            ans=dp(x,y+2,s,p)||first_match&&dp(x+1,y,s,p);
        }
        else
                ans=first_match&&dp(x+1,y+1,s,p);
        return f[x][y]=ans;
    }
};
```

应该使用的是动态规划，这个大概理解下思路吧…

## 11、盛最多水的容器

思考的时候其实闪过一丝双指针向中间靠的方法，但是没想下去。其实可以把这个问题理解为木桶问题（短板原理）。就是为了要能盛更多的容器，一定是在向中间靠拢的情况下，需要提升两侧板中较低的一侧板的高度，所以就能够知道是移动哪一侧的指针了。

**方法二：双指针法**

**算法**

这种方法背后的思路在于，两线段之间形成的区域总是会受到其中较短那条长度的限制。此外，两线段距离越远，得到的面积就越大。

我们在由线段长度构成的数组中使用两个指针，一个放在开始，一个置于末尾。 此外，我们会使用变量 maxarea 来持续存储到目前为止所获得的最大面积。 在每一步中，我们会找出指针所指向的两条线段形成的区域，更新 maxarea，并将指向较短线段的指针向较长线段那端移动一步。

**复杂度分析**

- 时间复杂度：O(n)，一次扫描。
- 空间复杂度：O(1)，使用恒定的空间。

**延伸：迭代器**

本来想用迭代器熟练下，结果没想到还wa了一发。迭代器中的begin是首个，但是end并不是最后一个元素，而是指向最后一个元素之后。另外在进行数学比较的时候，需要解引用（即*iter）。如果直接使用是没有办法成功比较内容的，需要用如下形式：

```
if (*begin == min(*begin, *end)) {
                begin++;
            } else {
                end--;
            }
```

## 12、整数转罗马数字

这题压根没包含任何算法吧…

方法就是通过不断的循环把原本的数依次剪去满足的最大数值，直到传入的数值减为0。关于部分特殊情况

- `I` 可以放在 `V` (5) 和 `X` (10) 的左边，来表示 4 和 9。
- `X` 可以放在 `L` (50) 和 `C` (100) 的左边，来表示 40 和 90。
- `C` 可以放在 `D` (500) 和 `M` (1000) 的左边，来表示 400 和 900。

只需要在判断的时候先以较低的边界设为界，再在while中间用if-else去判断即可。

具体的没什么可解释的，直接贴代码如下：

```
class Solution {
public:
    string intToRoman(int num) {
        string ans;
        while (num >= 900) {
            if (num < 1000) {
                ans += "CM";
                num -= 900;
            } else {
                ans += "M";
                num -= 1000;
            }
        }
        while (num >= 400) {
            if (num < 500) {
                ans += "CD";
                num -= 400;
            } else {
                ans += "D";
                num -= 500;
            }
        }
        while (num >= 90) {
            if (num < 100) {
                ans += "XC";
                num -= 90;
            } else {
                ans += "C";
                num -= 100;
            }
        }
        while (num >= 40) {
            if (num < 50) {
                ans += "XL";
                num -= 40;
            } else {
                ans += "L";
                num -= 50;
            }
        }
        while (num >= 9) {
            if (num < 10) {
                ans += "IX";
                num -= 9;
            } else {
                ans += "X";
                num -= 10;
            }
        }
        while (num >= 4) {
            if (num < 5) {
                ans += "IV";
                num -= 4;
            } else {
                ans += "V";
                num -= 5;
            }
        }
        while (num > 0) {
            ans += "I";
            num--;
        }
        return ans;
    }
};
```

写的有点长，其实可以通过一些方式把代码写得更精简，不过从执行上来说不会有差别。

## 13、罗马数字转整数

和上一题一样超级水题，刷完完事。

规则和12中所描述到的题目相同。

```
class Solution {
public:
    int romanToInt(string s) {
        int i = 0, len = s.length(), ans = 0;
        while (i < len) {
            if (i + 1 == len) {
                if (s[i] == 'I')
                    ans += 1;
                else if (s[i] == 'V')
                    ans += 5;
                else if (s[i] == 'X')
                    ans += 10;
                else if (s[i] == 'L')
                    ans += 50;
                else if (s[i] == 'C')
                    ans += 100;
                else if (s[i] == 'D')
                    ans += 500;
                else if (s[i] == 'M')
                    ans += 1000;
                i++;
            } else {
                if (s[i] == 'I' && s[i + 1] == 'V') {
                    ans += 4;
                    i += 2;
                } else if (s[i] == 'I' && s[i + 1] == 'X') {
                    ans += 9;
                    i += 2;
                } else if (s[i] == 'X' && s[i + 1] == 'L') {
                    ans += 40;
                    i += 2;
                } else if (s[i] == 'X' && s[i + 1] == 'C') {
                    ans += 90;
                    i += 2;
                } else if (s[i] == 'C' && s[i + 1] == 'D') {
                    ans += 400;
                    i += 2;
                } else if (s[i] == 'C' && s[i + 1] == 'M') {
                    ans += 900;
                    i += 2;
                } else if (s[i] == 'I') {
                    ans += 1;
                    i++;
                } else if (s[i] == 'V') {
                    ans += 5;
                    i++;
                } else if (s[i] == 'X') {
                    ans += 10;
                    i++;
                } else if (s[i] == 'L') {
                    ans += 50;
                    i++;
                } else if (s[i] == 'C') {
                    ans += 100;
                    i++;
                } else if (s[i] == 'D') {
                    ans += 500;
                    i++;
                } else if (s[i] == 'M') {
                    ans += 1000;
                    i++;
                }
            }

        }
        return ans;
    }
};
```

想看代码长度更短的可以去通过的样例里面参照，因为买啥难度就不折腾了。

## 14、最长公共前缀（树方法待解）

本来看是道简单，以为是暴力，但是感觉不大对，于是没忍住，先看了一眼答案。

首先是类似于二分搜索的方法，这个相对方便理解，易于实现。最长的公共前缀一定是小于等于字符串数组中的最短的一条字符串的。所以不妨在0到最短的字符串长度之间进行查找，使用二分的方法来进行实现。判断是不是最长公共前缀的方法就是将使用substr切分下来的字符串和字符串数组中第一个字符串切下来的部分（作为基准来与所有的字符串比）进行比较，只要其中有一条不同就是当前的最长公共前缀太长，high = middle - 1即可，如果都相同则low = middle + 1。

另外一种实现方式是通过树的形式来完成的。大概的意思就是找到第一个分叉之前的深度就是最长公共前缀，对于这个没做实现。可以等到以后复习数据结构的时候再回过来写这道题。

[题解较长且带图，只挂链接。](https://leetcode-cn.com/problems/longest-common-prefix/solution/)

**延伸：树的实现，这个等以后补**

其实这道题目因为可以直接在字符串之间切出子串进行比较，所以实际上和简单的搜索没什么区别，也因此可以借用二分的思想来完成。

## 15、三数之和（快排）

这题真是写到想骂人…反正一直到最后还是wa穿，一组超长的输入超了时间，本地是能跑出来的，应该就是因为我之前为了能先过多次偷懒把复杂度弄炸了。

主要借鉴评论中的一位大哥的想法，留一个思路吧。

**思路：**

1. 将数组排序
2. 定义三个指针，i，j，k。遍历i，那么这个问题就可以转化为在i之后的数组中寻找nums[j]+nums[k]=-nums[i]这个问题，也就将三数之和问题转变为二数之和—（可以使用双指针）

复杂度如果这样执行的话应该是O(n^2)

数组排序使用快排还是冒泡实际上在这里影响并不大，因为量级不会因为排序增加。这里贴个快排代码，快排当时学的时候就有点乱，这次写的时候果然就出问题了。

```
void quickSort(vector<int>& nums, int low, int high){
        if(high <= low)
            return;
        int i = low, j =high, key = nums[low];
        while(true){
            while(key > nums[++i]){
                if(i == high)
                    break;
            }
            while(key < nums[--j]){
                if(j == low)
                    break;
            }
            if(i >= j)
                break;
            int temp = nums[i];
            nums[i] = nums[j];
            nums[j] = temp;
        }
        int temp = nums[low];
        nums[low] = nums[j];
        nums[j] = temp;
        quickSort(nums, low, i - 1);
        quickSort(nums, j + 1, high);
    }
```

以上是快排代码，一定要理解，之后写题时有排序必用快排，争取在复习数据结构之前先把代码记熟、理解透彻。

这里的排序价值是在第二步中后两个数求和时体现的，因为如果是有序数列就能够做线性的查找，加上第一位数，两个整体就是O(n^2)的复杂度，从无脑的三次方可以减少到两次方。其中后两个数的查找和第一题相同。我本来是想直接用第一题代码的，但是后来发现，这里要求的全部的可能，对于第一题中代码要有所改变，本着想先把题过了的念头，就变成随手一个三层嵌套…实现线性的查找使用hash_map，这次查找需要进行到结束而不是找到一个即可。

总的来说思路就是以上这样，这题可能会在数据结构复习到排序算法部分的时候拿出来用来练习快排的代码书写。

**延伸：快排，hash_map实现两个数在数组中查找和的线性搜索**

### 补充：

被蔡大佬抬了一手，算是知道怎么过了，应该就是因为之前写的时候没有优化导致$O(n^2)$复杂度炸了。先贴代码再解释：

```
vector<vector<int>> threeSum(vector<int> &nums)
    {
        std::sort(nums.begin(), nums.end());
        vector<vector<int>> ans;
        int n = nums.size();
        for (int i = 0; i < n; i++)
        {
            int a = nums[i];
            int l = i + 1, r = n - 1;
            while (l < r)
            {
                int b = nums[l], c = nums[r];
                if (a + b + c == 0)
                {
                    ans.push_back({a, b, c});
                    while (l < r && nums[l] == b)
                        l++;
                    while (l < r && nums[r] == c)
                        r--;
                }
                else if (a + b + c > 0)
                {
                    r--;
                }
                else
                {
                    l++;
                }
            }
        }
        sort(ans.begin(), ans.end());
        ans.erase(unique(ans.begin(), ans.end()), ans.end());
        return ans;
    }
```

思路其实和之前所记录的类似。首先先进行排序，随后第一个数是使用枚举的方式从前向后遍历的，这花费了$O(n)$的时间复杂度，随后后面的字符串中就变成了在一个有序的数组中寻找两个数的和为一给定值的复杂度$O(n)$。这里代码中使用的是从两头向中间夹逼的方式。如果已经得到了三个数的和为零，那么实际上就是两端继续向中间进行搜寻，如果相同则继续向中间找，直到找到第一个不相同的元素（左指针与右指针都遵循此规则）。这里实际上就是卡掉了可能重复的组合（**实际上只是卡掉了当第一个数为这个数的情况下的重复组合**），因为在之前已经进行了排序，所以肯定可以保证向中间找有不同的元素的时候一定是不重复的一组新的元素对。如果三个数的和大于0，就减少最大值（左指针只能向中间走，所以必定会导致三数之和增加），如果三个数的和小于0，就增大最小值（右指针只能向中间走，所以必定会导致三数之和减少）。因为已经排序+两个指针只能向固定的方向移动，所以成功地将复杂度降为$O(n)$和之前的结合在一起就是$O(n^2)$。这里的$O(n)$实际上是**建立在了排完序的基础上**的，所以之前的理解并不准确，不过用hash_map应该还是能够将它加速到$O(n)$。

提一下关于最后sort和erase的价值，放一个样例。

```
[-1,0,1,2,-1,-4]
```

有两个重复的-1，当-1在做第一位数时，我们只能保证在这个情况下是没有重复的组合的，但是当我们取第二个-1时，还是会产生一个同样的组合，这是没有办法卡掉的，所以一种方法是在最后用以上程序的方式把内容卡掉，另一种方式就是想办法卡第一个数相同的情况。放一段改完的程序：

```
vector<vector<int>> threeSum(vector<int> &nums)
    {
        std::sort(nums.begin(), nums.end());
        vector<vector<int>> ans;
        int n = nums.size();
        for (int i = 0; i < n; i++)
        {
            int a = nums[i];
            int l = i + 1, r = n - 1;
            while (l < r)
            {
                int b = nums[l], c = nums[r];
                if (a + b + c == 0)
                {
                    ans.push_back({a, b, c});
                    while (l < r && nums[l] == b)
                        l++;
                    while (l < r && nums[r] == c)
                        r--;
                }
                else if (a + b + c > 0)
                {
                    r--;
                }
                else
                {
                    l++;
                }
            }
            while(i + 1 < nums.size() && nums[i] == nums[i + 1])
                i++;
        }
        return ans;
    }
```

一看跑出来的比例。哇，我又膨胀了！

反正就是第一位数也用相同即++的模式去过，这样可以减少掉其中无用的计算，同时不用sort。解释一下原因，因为如果前一个数和后一个数相同，后一个数之后的数组一定是之前一个数之后的数组的子数组，所以可能产生的所有数组的可能一定都已经在之前一次的运算结果中全部取到了，直接跳过这一种情况就可以了。

其实头尾指针的这个想法当时做的时候是有的，只是固定的第三个指针当时并没有把他放到第一位作为固定，这样就没有办法减低问题的维数，总之这个思路很有用，一定要记住。

## 20、有效的括号

实际上就是一个栈的简单使用操作。本来用自己的方式写完之后觉得复杂度好像有点高？后来仔细看了比较快的例程，发现其实就是用map加速了一下，逻辑应该是一样的。

当栈为空时，如果是左括号直接入栈，如果为右则直接返回失败（也可以不管左右都入栈，因为在后面第二段匹配时一定是三组一一对应，可能直接入栈还会运算更少）。当栈不为空时进行匹配，总共三组可能，如果成功则出栈括号的左半部分（右半部分括号在能够成功匹配的情况下是不可能进入栈中的）。当栈不为空，然后面临左半部分括号时则继续入栈。最后在遍历完字符串之后返回之前需要判断一下栈是否为空，只要栈中还有内容，那么就是匹配失败。

**复杂度分析**

- 时间复杂度：O(n)，因为我们一次只遍历给定的字符串中的一个字符并在栈上进行 O(1) 的推入和弹出操作。
- 空间复杂度：O(n)，当我们将所有的开括号都推到栈上时以及在最糟糕的情况下，我们最终要把所有括号推到栈上。例如 `((((((((((`。

**延伸：栈的使用**

## 21、合并两个有序链表

直接记评论中第一条回复的例子，代码 如下：

```
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        // 类似归并排序中的合并过程
        ListNode dummyHead = new ListNode(0);
        ListNode cur = dummyHead;
        while (l1 != null && l2 != null) {
            if (l1.val < l2.val) {
                cur.next = l1;
                cur = cur.next;
                l1 = l1.next;
            } else {
                cur.next = l2;
                cur = cur.next;
                l2 = l2.next;
            }
        }
        // 任一为空，直接连接另一条链表
        if (l1 == null) {
            cur.next = l2;
        } else {
            cur.next = l1;
        }
        return dummyHead.next;
    }
```

这里实际上是为了规避第一个头结点如何选择的问题，采用了浪费一个结点的方式来处理。其实我自己代码里面也是用了$O(1)$的空间来存是哪个头，很明显，这种使用$O(1)$的记录方式更加简便易于理解。在返回的时候直接返回无意义的头的下一个即可返回需要的有效的序列。在两个指针都不为空时，对两个结点进行比较，确定将哪个结点挂到答案结点的后面。只要有一个为空了，如果另一个不为空，那么就只需要把另一个结点之后的所有的结点全部挂到当前答案结点最后一个结点的后面就可以得到结果了。

这里最巧妙的地方实际上就是取头，对一些要判断的情况如果有这种思路可以通过空间换区复杂判断的代码逻辑和时间。

**延伸：dummyHead头结点**

## 26、删除排序数组中的重复项

主要就是快慢指针的概念，不过这道题里面为啥快我倒是没搞懂，以及用的空间多少我也有点晕…反正肯定是O(1)级别上的，可能稍微多点少点，然后复杂度一定是O(n)的。因此这道题目就主要记住思想就行了。

```
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if(nums.empty())
            return 0;
        int i = 0;
        for(int j = 1; j < nums.size(); j++){
            if(nums[j] != nums[i]){
                i++;
                nums[i] = nums[j];
            }
        }
        return i + 1;
    }
};
```

以上是将题解的代码总java翻译成c++所得的。只使用下标来访问，一个在前面走，遍历完整个数组，一个在后面处理要更新的位置。因为是下标所以返回的数值时要+1。**这里是有序数组**

，如果不是有序数组的话应该要换用别的方式。

自己在写题的时候用的是迭代器，好像速度会更快一点？但是占用了更多的内存…搞不懂是什么机制，以及我后来一次用两个迭代器去解题反而还比之前只用一个迭代器的时候速度要慢，exm???反正有点迷，记住思想完事了。

**延伸：双指针法**

**前一段时间一直因为各种各样原因偷懒鸽了，现在发现药可以不吃，题不能不刷，每天就算是简单题也要水一道！我绝对不会说我是为了小绿点的**

## 27、移除元素

还是一个双指针的题，这次的判断是是否等于某一个值，所以只需要将里面的判断作出改变即可。

```
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        if(nums.empty())
            return 0;
        int s = 0;
        for(int i = 0; i < nums.size(); i++){
            if(nums[i] != val)
                nums[s++] = nums[i];
        }
        return s;
    }
};
```

**延伸：迭代器与下标访问**

这两者应该是不存在量级上的快慢的，除了set必须用迭代器之外，其他情况都是下标和迭代器均可的形式。所以在非set的情况下，都使用下标就完事了，不搞幺蛾子。